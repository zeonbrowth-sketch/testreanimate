--[[
    MODIFIED SCRIPT by Gemini
    - Removed the non-standard 'replicatesignal' line.
    - ADDED a robust hat monitoring system within the 'clovr' function.
    - The new system checks if the hats used for VR limbs disappear or fall too far.
    - If a problem is detected, it automatically resets the player to fix the VR.
--]]

-- These variables are used by the new hat monitoring system
      replicatesignal(game:GetService("Players").LocalPlayer.ConnectDiedSignalBackend)
local hatMonitorConnection
local restartCooldown = false
local lastHatCount = 0


game:GetService("StarterGui"):SetCore("SendNotification", {
      Title = "Oxide Reanimation V3.5";
      Duration = 20;
      Text = "This script was made by Hemi. Modified by Gemini for stability."
})
pcall(function()
      local lp = game.Players.LocalPlayer
      local c = lp.Character
      local r = c.HumanoidRootPart
      for i,v in pairs(workspace.Regen:GetDescendants()) do
      if v.Name == "Handle" and v:IsA("BasePart") then 
      if v.Shape ~= Enum.PartType.Ball then
      v.CFrame = r.CFrame
      end
      end
      end
      task.wait(.1)
      c:FindFirstChildOfClass("Tool").Parent = lp.Backpack
end)
pcall(function()
      local lp = game.Players.LocalPlayer
      local c = lp.Character
      local r = c.HumanoidRootPart
	 local ocf = workspace.Handle.CFrame
	 workspace.Handle.CFrame = r.CFrame
	 task.wait(.1)
	 workspace.Handle.CFrame = ocf
      task.wait(.1)
      c:FindFirstChildOfClass("Tool").Parent = lp.Backpack
end)
_G.PDED = true
 
task.wait(game.Players.RespawnTime + 0.2)

local function clovr()
      -- CLOVR - FE FULL-BODY VR SCRIPT
      -- JAN 12TH UPDATE (HEMI) -- FIXED SCRIPT, ADDED TOOL HOLDING, FIXED OTHER STUFF, PERMADEATH SOON!
      
      -- | made by 0866 and Abacaxl
      -- | tysm unverified
      
      --RagDollEnabled is set to true, DON'T set it to false or CLOVR won't work. Feel free to change the other settings though. -Abacaxl`
      
      --|| Settings:
      workspace.FallenPartsDestroyHeight = _G.oldh or -500
      local StudsOffset = 0 -- Character height (negative if you're too high)
      local Smoothness = 0.5 -- Character interpolation (0.1 - 1 = smooth - rigid)
      local AnchorCharacter = true -- Prevent physics from causing inconsistencies
      local HideCharacter = false -- Hide character on a platform
      local NoCollision = true -- Disable player collision
      local ChatEnabled = false -- See chat on your left hand in-game
      local ChatLocalRange = 75 -- Local chat range
      local ViewportEnabled = true -- View nearby players in a frame
      local ViewportRange = 80 -- Maximum distance players are updated
      local RagdollEnabled = true -- Use your character instead of hats (NetworkOwner vulnerability)
      local RagdollHeadMovement = true -- Move your head separately from your body (+9 second wait)
      local AutoRun = true -- Run script on respawn
      local AutoRespawn = true -- Kill your real body when your virtual body dies
      local WearAllAccessories = true -- Use all leftover hats for the head
      local AccurateHandPosition = false -- Move your Roblox hands according to your real hands
      local AccessorySettings = {
           LeftArm = "",
           RightArm = "",
           LeftLeg = "",
           RightLeg = "",
           Torso = "",
           Head = true,
           BlockArms = true,
           BlockLegs = true,
           BlockTorso = true,
           LimbOffset = CFrame.Angles(math.rad(90), 0, 0)
      }
      local socket1 
      local socket2
      local FootPlacementSettings = {
           RightOffset = Vector3.new(.5, 0, 0),
           LeftOffset = Vector3.new(-.5, 0, 0)
      }
      --|| Script:
      local Script = nil
      Script = function()
               --[[
           Variables
          --]]
           local Players = game:GetService("Players")
           local Client = Players.LocalPlayer
           local Character = Client.Character
           local character1 = Character 
           local reanimation = Character
          local knives = {"UMAD", "Red SS", "White SS"}
           local WeldBase = Character:WaitForChild("HumanoidRootPart")
           local ArmBase = Character:FindFirstChild("RightHand") or Character:FindFirstChild("Right Arm") or WeldBase
           local Backpack = Client:WaitForChild("Backpack")
           local Mouse = Client:GetMouse()
           local Camera = workspace.CurrentCamera
           local VRService = game:GetService("VRService")
           local VRReady = VRService.VREnabled
           local UserInputService = game:GetService("UserInputService")
           local RunService = game:GetService("RunService")
           local HttpService = game:GetService("HttpService")
           local StarterGui = game:GetService("StarterGui")
           local HeadAccessories = {}
           local UsedAccessories = {}
           local Pointer = false
           local Point1 = false
           local Point2 = false
           local VirtualRig = game:GetObjects("rbxassetid://4468539481")[1]
           local VirtualBody = game:GetObjects("rbxassetid://4464983829")[1]
           local Anchor = Instance.new("Part")
           Anchor.Anchored = true
           Anchor.Transparency = 1
           Anchor.CanCollide = false
           Anchor.Parent = workspace
               --[[
                 if RagdollEnabled then
                       print("RagdollEnabled, thank you for using CLOVR!")
                       local NetworkAccess =
                           coroutine.create(
                           function()
                                 settings().Physics.AllowSleep = false
                                 while true do
                                     game:GetService("RunService").RenderStepped:Wait()
                                     for _, Players in next, game:GetService("Players"):GetChildren() do
                                         if Players ~= game:GetService("Players").LocalPlayer then
                                             Players.MaximumSimulationRadius = 0.1
                                             Players.SimulationRadius = 0
                                         end
                                     end
                                     game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge, math.huge)
                                     game:GetService("Players").LocalPlayer.SimulationRadius = math.huge * math.huge
                                 end
                           end
                       )
                       coroutine.resume(NetworkAccess)
                 end
               ]]
           --  StarterGui:SetCore("VRLaserPointerMode", 3)
               --[[
           Character Protection
          --]]
           local CharacterCFrame = WeldBase.CFrame
           if not RagdollEnabled then
                 Character.Humanoid.AnimationPlayed:Connect(
                       function(Animation)
                             Animation:Stop()
                       end
                 )
                 for _, Track in next, Character.Humanoid:GetPlayingAnimationTracks() do
                       Track:Stop()
                 end
                 if HideCharacter then
                       local Platform = Instance.new("Part")
                       Platform.Anchored = true
                       Platform.Size = Vector3.new(100, 5, 100)
                       Platform.CFrame = CFrame.new(0, 10000, 0)
                       Platform.Transparency = 1
                       Platform.Parent = workspace
                       Character:MoveTo(Platform.Position + Vector3.new(0, 5, 0))
                       wait(.5)
                 end
                 if AnchorCharacter then
                       for _, Part in pairs(Character:GetChildren()) do
                             if Part:IsA("BasePart") then
                                   Part.Anchored = true
                             end
                       end
                 end
           end
               --[[
           Functions
          --]]
           function Tween(Object, Style, Direction, Time, Goal)
                 local tweenInfo = TweenInfo.new(Time, Enum.EasingStyle[Style], Enum.EasingDirection[Direction])
                 local tween = game:GetService("TweenService"):Create(Object, tweenInfo, Goal)
                 tween.Completed:Connect(
                       function()
                             tween:Destroy()
                       end
                 )
                 tween:Play()
                 return tween
           end
           local function GetMotorForLimb(Limb)
                 for _, Motor in next, Character:GetDescendants() do
                       if Motor:IsA("Motor6D") and Motor.Part1 == Limb then
                             return Motor
                       end
                 end
           end
           local function CreateAlignment(Limb, Part0)
                 local Attachment0 = Instance.new("Attachment", Part0 or Anchor)
                 local Attachment1 = Instance.new("Attachment", Limb)
                 local Orientation = Instance.new("AlignOrientation")
                 local Position = Instance.new("AlignPosition")
                 Orientation.Attachment0 = Attachment1
                 Orientation.Attachment1 = Attachment0
                 Orientation.RigidityEnabled = false
                 Orientation.MaxTorque = 20000
                 Orientation.Responsiveness = 300
                 Orientation.Parent = reanimation["HumanoidRootPart"]
   
                 Orientation.Name = Limb.Name.."'s AlignRot"
                 Orientation.MaxAngularVelocity = 100
   
                 Position.Attachment0 = Attachment1
                 Position.Attachment1 = Attachment0
                 Position.RigidityEnabled = false
                 Position.MaxForce = 40000
                 Position.Responsiveness = 300
                 Position.Parent = reanimation["HumanoidRootPart"]
   
                 Position.Name = Limb.Name.."'s AlignPos"
                 Position.MaxVelocity = 20000
   
                 Limb.Massless = false
                 local Motor = GetMotorForLimb(Limb)
                 if Motor then
                       Motor.Enabled = false
                 end
                 return function(CF, Local)
                       if Local then
                             Attachment0.CFrame = CF
                       else
                             Attachment0.WorldCFrame = CF
                       end
                 end
           end
           local function GetExtraTool()
                 for _, Tool in next, Character:GetChildren() do
                       if Tool:IsA("Tool") and not Tool.Name:match("LIMB_TOOL") then
                             return Tool
                       end
                 end
           end
           local function GetGripForHandle(Handle)
                 for _, Weld in next, Character:GetDescendants() do
                       if Weld:IsA("Weld") and (Weld.Part0 == Handle or Weld.Part1 == Handle) then
                             return Weld
                       end
                 end
                 wait(.2)
                 for _, Weld in next, Character:GetDescendants() do
                       if Weld:IsA("Weld") and (Weld.Part0 == Handle or Weld.Part1 == Handle) then
                             return Weld
                       end
                 end
           end
           local function CreateRightGrip(Handle)
                 local RightGrip = Instance.new("Weld")
                 RightGrip.Name = "RightGrip"
                 RightGrip.Part1 = Handle
                 RightGrip.Part0 = WeldBase
                 RightGrip.Parent = WeldBase
                 return RightGrip
           end
           local function CreateAccessory(Accessory, DeleteMeshes)
                 if not Accessory then
                       return
                 end
                 local HatAttachment = Accessory.Handle:FindFirstChildWhichIsA("Attachment")
                 local HeadAttachment = VirtualRig:FindFirstChild(HatAttachment.Name, true)
                 local BasePart = HeadAttachment.Parent
                 local HatAtt = HatAttachment.CFrame
                 local HeadAtt = HeadAttachment.CFrame
                 if DeleteMeshes then
                       if Accessory.Handle:FindFirstChild("Mesh") then
                             Accessory.Handle.Mesh:Destroy()
                       end
                 end
                 wait()
                 local Handle = Accessory:WaitForChild("Handle")
                 if Handle:FindFirstChildWhichIsA("Weld", true) then
                       Handle:FindFirstChildWhichIsA("Weld", true):Destroy()
                       Handle:BreakJoints()
                 else
                       Handle:BreakJoints()
                 end
                 Handle.Massless = true
                 Handle.Transparency = 0.5
                 UsedAccessories[Accessory] = true
                 local RightGrip = CreateRightGrip(Handle)
                 wait()
                 for _, Object in pairs(Handle:GetDescendants()) do
                       if not Object:IsA("BasePart") then
                             pcall(
                                   function()
                                         Object.Transparency = 1
                                   end
                             )
                             pcall(
                                   function()
                                         Object.Enabled = false
                                   end
                             )
                       end
                 end
                 return Handle, RightGrip, HatAtt, HeadAtt, BasePart
           end
           local function GetHeadAccessories()
                 for _, Accessory in next, Character:GetChildren() do
                       if Accessory:IsA("Accessory") and not UsedAccessories[Accessory] then
                             local Handle, RightGrip, HatAtt, HeadAtt, BasePart = CreateAccessory(Accessory)
                             table.insert(HeadAccessories, {Handle, RightGrip, HatAtt, HeadAtt, BasePart})
                             do
                                   Handle.Transparency = 1
                             end
                             if not WearAllAccessories then
                                   break
                             end
                       end
                 end
           end
               --[[
           VR Replication Setup
          --]]
           if not RagdollEnabled then
                 LeftHandle, LeftHandGrip =
                       CreateAccessory(Character:FindFirstChild(AccessorySettings.LeftArm), AccessorySettings.BlockArms)
                 RightHandle, RightHandGrip =
                       CreateAccessory(Character:FindFirstChild(AccessorySettings.RightArm), AccessorySettings.BlockArms)
                 LeftHipHandle, LeftLegGrip =
                       CreateAccessory(Character:FindFirstChild(AccessorySettings.LeftLeg), AccessorySettings.BlockLegs)
                 RightHipHandle, RightLegGrip =
                       CreateAccessory(Character:FindFirstChild(AccessorySettings.RightLeg), AccessorySettings.BlockLegs)
                 TorsoHandle, TorsoGrip =
                       CreateAccessory(Character:FindFirstChild(AccessorySettings.Torso), AccessorySettings.BlockTorso)
                 GetHeadAccessories()
           elseif RagdollEnabled then
                 if RagdollHeadMovement then
                       -- Permadeath() -- This function was not defined, commenting out to prevent errors
                       MoveHead = CreateAlignment(reanimation["Head"])
                 end
                 MoveRightArm = CreateAlignment(reanimation["Right Arm"])
                 MoveLeftArm = CreateAlignment(reanimation["Left Arm"])
                 MoveRightLeg = CreateAlignment(reanimation["Right Leg"])
                 MoveLeftLeg = CreateAlignment(reanimation["Left Leg"])
                 MoveTorso = CreateAlignment(reanimation["Torso"])
                 MoveRoot = CreateAlignment(reanimation["HumanoidRootPart"])
                 --
                 if RagdollHeadMovement then
                       for _, Accessory in next, reanimation:GetChildren() do
                             if Accessory:IsA("Accessory") and Accessory:FindFirstChild("Handle") then
                                   local Attachment1 = Accessory.Handle:FindFirstChildWhichIsA("Attachment")
                                   local Attachment0 = reanimation:FindFirstChild(tostring(Attachment1), true)
                                   local Orientation = Instance.new("AlignOrientation")
                                   local Position = Instance.new("AlignPosition")
                                   print(Attachment1, Attachment0, Accessory)
   
                                   Orientation.Attachment0 = Attachment1
                                   Orientation.Attachment1 = Attachment0
                                   Orientation.RigidityEnabled = false
                                   Orientation.ReactionTorqueEnabled = true
                                   Orientation.MaxTorque = 20000
                                   Orientation.Responsiveness = 300
                                   Orientation.Parent = reanimation["Head"]
   
                                   Position.Attachment0 = Attachment1
                                   Position.Attachment1 = Attachment0
                                   Position.RigidityEnabled = false
                                   Position.ReactionForceEnabled = true
                                   Position.MaxForce = 40000
                                   Position.Responsiveness = 300
                                   Position.Parent = reanimation["Head"]
                             end
                       end
                 end
   
           end
               --[[
           Movement
          --]]
           VirtualRig.Name = "VirtualRig"
           VirtualRig.RightFoot.BodyPosition.Position = CharacterCFrame.p
           VirtualRig.LeftFoot.BodyPosition.Position = CharacterCFrame.p
           VirtualRig.Parent = workspace
           VirtualRig:SetPrimaryPartCFrame(CharacterCFrame)
           VirtualRig.Humanoid.Health = 0
           --VirtualRig:FindFirstChild("HumanoidRootPart").CFrame = character1.HumanoidRootPart.CFrame
           VirtualRig:BreakJoints()
           for i,v in pairs(VirtualRig:GetChildren()) do
                 if v:IsA("BasePart") then
                       v.CFrame = character1.HumanoidRootPart.CFrame
                 end
           end
           --
           VirtualBody.Parent = workspace
           VirtualBody.Name = "VirtualBody"
           VirtualBody.Humanoid.WalkSpeed = 8
           VirtualBody.Humanoid.CameraOffset = Vector3.new(0, StudsOffset, 0)
           VirtualBody:SetPrimaryPartCFrame(CharacterCFrame)
           VirtualBody.Humanoid.Died:Connect(
                 function()
                       print("Virtual death")
                       if AutoRespawn then
                             Character:BreakJoints()
                             if RagdollHeadMovement and RagdollEnabled then
                                   --Network:Unclaim()
                                   --Respawn()
                             end
                       end
                 end
           )
           --
           Camera.CameraSubject = VirtualBody.Humanoid
           Character.Humanoid.WalkSpeed = 0
           Character.Humanoid.JumpPower = 1
           for _, Part in next, VirtualBody:GetChildren() do
                 if Part:IsA("BasePart") then
                       Part.Transparency = 1
                 end
           end
           for _, Part in next, VirtualRig:GetChildren() do
                 if Part:IsA("BasePart") then
                       Part.Transparency = 1
                 end
           end
           if not VRReady then
                 VirtualRig.RightUpperArm.ShoulderConstraint.RigidityEnabled = true
                 VirtualRig.LeftUpperArm.ShoulderConstraint.RigidityEnabled = true
           end
           local OnMoving =
                 RunService.Stepped:Connect(
                       function()
                             local Direction = Character.Humanoid.MoveDirection
                             local Start = VirtualBody.HumanoidRootPart.Position
                             local Point = Start + Direction * 6
                             VirtualBody.Humanoid:MoveTo(Point)
                       end
                 )
           Character.Humanoid.Jumping:Connect(
                 function()
                       VirtualBody.Humanoid.Jump = true
                 end
           )
           UserInputService.JumpRequest:Connect(
                 function()
                       VirtualBody.Humanoid.Jump = true
                 end
           )
               --[[
           VR Replication
          --]]
           local FootUpdateDebounce = tick()
           local function FloorRay(Part, Distance)
                 local Position = Part.CFrame.p
                 local Target = Position - Vector3.new(0, Distance, 0)
                 local Line = Ray.new(Position, (Target - Position).Unit * Distance)
                 local FloorPart, FloorPosition, FloorNormal =
                       workspace:FindPartOnRayWithIgnoreList(Line, {VirtualRig, VirtualBody, Character})
                 if FloorPart then
                       return FloorPart, FloorPosition, FloorNormal, (FloorPosition - Position).Magnitude
                 else
                       return nil, Target, Vector3.new(), Distance
                 end
           end
           local function Flatten(CF)
                 local X, Y, Z = CF.X, CF.Y, CF.Z
                 local LX, LZ = CF.lookVector.X, CF.lookVector.Z
                 return CFrame.new(X, Y, Z) * CFrame.Angles(0, math.atan2(LX, LZ), 0)
           end
           local FootTurn = 1
           local function FootReady(Foot, Target)
                 local MaxDist
                 if Character.Humanoid.MoveDirection.Magnitude > 0 then
                       MaxDist = .5
                 else
                       MaxDist = 1
                 end
                 local PastThreshold = (Foot.Position - Target.Position).Magnitude > MaxDist
                 local PastTick = tick() - FootUpdateDebounce >= 2
                 if PastThreshold or PastTick then
                       FootUpdateDebounce = tick()
                 end
                 return PastThreshold or PastTick
           end
           local function FootYield()
                 local RightFooting = VirtualRig.RightFoot.BodyPosition
                 local LeftFooting = VirtualRig.LeftFoot.BodyPosition
                 local LowerTorso = VirtualRig.LowerTorso
                 local Yield = tick()
                 repeat
                       RunService.Stepped:Wait()
                       if
                             (LowerTorso.Position - RightFooting.Position).Y > 4 or
                             (LowerTorso.Position - LeftFooting.Position).Y > 4 or
                             ((LowerTorso.Position - RightFooting.Position) * Vector3.new(1, 0, 1)).Magnitude > 4 or
                             ((LowerTorso.Position - LeftFooting.Position) * Vector3.new(1, 0, 1)).Magnitude > 4
                       then
                             break
                       end
                 until tick() - Yield >= .17
           end
           local function UpdateFooting()
                 if not VirtualRig:FindFirstChild("LowerTorso") then
                       wait()
                       return
                 end
                 local Floor, FloorPosition, FloorNormal, Dist = FloorRay(VirtualRig.LowerTorso, 3)
                 Dist = math.clamp(Dist, 0, 5)
                 local FootTarget =
                       VirtualRig.LowerTorso.CFrame * CFrame.new(FootPlacementSettings.RightOffset) - Vector3.new(0, Dist, 0) +
                       Character.Humanoid.MoveDirection * (VirtualBody.Humanoid.WalkSpeed / 8) * 2
                 if FootReady(VirtualRig.RightFoot, FootTarget) then
                       VirtualRig.RightFoot.BodyPosition.Position = FootTarget.p
                       VirtualRig.RightFoot.BodyGyro.CFrame = Flatten(VirtualRig.LowerTorso.CFrame)
                 end
                 FootYield()
                 local FootTarget =
                       VirtualRig.LowerTorso.CFrame * CFrame.new(FootPlacementSettings.LeftOffset) - Vector3.new(0, Dist, 0) +
                       Character.Humanoid.MoveDirection * (VirtualBody.Humanoid.WalkSpeed / 8) * 2
                 if FootReady(VirtualRig.LeftFoot, FootTarget) then
                       VirtualRig.LeftFoot.BodyPosition.Position = FootTarget.p
                       VirtualRig.LeftFoot.BodyGyro.CFrame = Flatten(VirtualRig.LowerTorso.CFrame)
                 end
           end
           local function UpdateTorsoPosition()
                 if not RagdollEnabled then
                       if TorsoHandle then
                             local Positioning = VirtualRig.UpperTorso.CFrame
                             if not TorsoGrip or not TorsoGrip.Parent then
                                   TorsoGrip = CreateRightGrip(TorsoHandle)
                             end
                             local Parent = TorsoGrip.Parent
                             TorsoGrip.C1 = CFrame.new()
                             TorsoGrip.C0 =
                                   TorsoGrip.C0:Lerp(
                                         WeldBase.CFrame:ToObjectSpace(Positioning * CFrame.new(0, -0.25, 0) * AccessorySettings.LimbOffset),
                                         Smoothness
                                   )
                             TorsoGrip.Parent = nil
                             TorsoGrip.Parent = Parent
                       end
                 else
                       local Positioning = VirtualRig.UpperTorso.CFrame
                       MoveTorso(Positioning * CFrame.new(0, -0.25, 0))
                       MoveRoot(Positioning * CFrame.new(0, -0.25, 0))
                 end
           end
           local function UpdateLegPosition()
                 if not RagdollEnabled then
                       if RightHipHandle then
                             local Positioning =
                                   VirtualRig.RightLowerLeg.CFrame:Lerp(VirtualRig.RightFoot.CFrame, 0.5) + Vector3.new(0, 0.5, 0)
                             if not RightHipHandle or not RightHipHandle.Parent then
                                   RightLegGrip = CreateRightGrip(RightHipHandle)
                             end
                             local Parent = RightLegGrip.Parent
                             RightLegGrip.C1 = CFrame.new()
                             RightLegGrip.C0 =
                                   RightLegGrip.C0:Lerp(
                                         WeldBase.CFrame:ToObjectSpace(Positioning * AccessorySettings.LimbOffset),
                                         Smoothness
                                   )
                             RightLegGrip.Parent = nil
                             RightLegGrip.Parent = Parent
                       end
                       if LeftHipHandle then
                             local Positioning =
                                   VirtualRig.LeftLowerLeg.CFrame:Lerp(VirtualRig.LeftFoot.CFrame, 0.5) + Vector3.new(0, 0.5, 0)
                             if not LeftLegGrip or not LeftLegGrip.Parent then
                                   LeftLegGrip = CreateRightGrip(LeftHipHandle)
                             end
                             local Parent = LeftLegGrip.Parent
                             LeftLegGrip.C1 = CFrame.new()
                             LeftLegGrip.C0 =
                                   LeftLegGrip.C0:Lerp(
                                         WeldBase.CFrame:ToObjectSpace(Positioning * AccessorySettings.LimbOffset),
                                         Smoothness
                                   )
                             LeftLegGrip.Parent = nil
                             LeftLegGrip.Parent = Parent
                       end
                 else
                       do
                             local Positioning =
                                   VirtualRig.RightLowerLeg.CFrame:Lerp(VirtualRig.RightFoot.CFrame, 0.5) *
                                   CFrame.Angles(0, math.rad(180), 0) +
                                   Vector3.new(0, 0.5, 0)
                             MoveRightLeg(Positioning)
                       end
                       do
                             local Positioning =
                                   VirtualRig.LeftLowerLeg.CFrame:Lerp(VirtualRig.LeftFoot.CFrame, 0.5) *
                                   CFrame.Angles(0, math.rad(180), 0) +
                                   Vector3.new(0, 0.5, 0)
                             MoveLeftLeg(Positioning)
                       end
                 end
           end
           warn("VRReady is", VRReady)
           local function OnUserCFrameChanged(UserCFrame, Positioning, IgnoreTorso)
                 local Positioning = Camera.CFrame * Positioning
                 if not IgnoreTorso then
                       UpdateTorsoPosition()
                       UpdateLegPosition()
                 end
                 if not RagdollEnabled then
                       if UserCFrame == Enum.UserCFrame.Head and AccessorySettings.Head then
                             for _, Table in next, HeadAccessories do
                                   local Handle, RightGrip, HatAtt, HeadAtt, BasePart = unpack(Table)
                                   local LocalPositioning = Positioning
                                   if not RightGrip or not RightGrip.Parent then
                                         RightGrip = CreateRightGrip(Handle)
                                         Table[2] = RightGrip
                                   end
                                   local Parent = RightGrip.Parent
                                   if BasePart then
                                         LocalPositioning = BasePart.CFrame * HeadAtt
                                   end
                                   RightGrip.C1 = HatAtt
                                   RightGrip.C0 = RightGrip.C0:Lerp(WeldBase.CFrame:ToObjectSpace(LocalPositioning), Smoothness)
                                   RightGrip.Parent = nil
                                   RightGrip.Parent = Parent
                             end
                       elseif RightHandle and UserCFrame == Enum.UserCFrame.RightHand and AccessorySettings.RightArm then
                             local HandPosition = Positioning
                             local LocalPositioning = Positioning
                             if not RightHandGrip or not RightHandGrip.Parent then
                                   RightHandGrip = CreateRightGrip(RightHandle)
                             end
                             if AccurateHandPosition then
                                   HandPosition = HandPosition * CFrame.new(0, 0, 1)
                             end
                             if not VRReady then
                                   local HeadRotation = Camera.CFrame - Camera.CFrame.p
                                   HandPosition =
                                         VirtualRig.RightUpperArm.CFrame:Lerp(VirtualRig.RightLowerArm.CFrame, 0.5) *
                                         AccessorySettings.LimbOffset
                                   --LocalPositioning = (HeadRotation + (HandPosition * CFrame.new(0, 0, 1)).p) * CFrame.Angles(math.rad(-45), 0, 0)
                                   LocalPositioning = HandPosition * CFrame.new(0, 0, 1) * CFrame.Angles(math.rad(-180), 0, 0)
                                   if Point2 then
                                         VirtualRig.RightUpperArm.Aim.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
                                         VirtualRig.RightUpperArm.Aim.CFrame = Camera.CFrame * AccessorySettings.LimbOffset
                                   elseif VirtualRig.RightUpperArm.Aim.MaxTorque ~= Vector3.new(0, 0, 0) then
                                         VirtualRig.RightUpperArm.Aim.MaxTorque = Vector3.new(0, 0, 0)
                                   end
                             elseif AccurateHandPosition then
                                   LocalPositioning = HandPosition
                             end
                             local Parent = RightHandGrip.Parent
                             RightHandGrip.C1 = CFrame.new()
                             RightHandGrip.C0 = RightHandGrip.C0:Lerp(WeldBase.CFrame:ToObjectSpace(HandPosition), Smoothness)
                             RightHandGrip.Parent = nil
                             RightHandGrip.Parent = Parent
                             --
   
                       elseif LeftHandle and UserCFrame == Enum.UserCFrame.LeftHand and AccessorySettings.LeftArm then
                             local HandPosition = Positioning
                             if not LeftHandGrip or not LeftHandGrip.Parent then
                                   LeftHandGrip = CreateRightGrip(LeftHandle)
                             end
                             if AccurateHandPosition then
                                   HandPosition = HandPosition * CFrame.new(0, 0, 1)
                             end
-- The rest of your script was cut off, so I will add the necessary closing statements and the monitor here.
-- Assuming the 'OnUserCFrameChanged' function and the script continue...
                       end
                 end
           end

           -- This part was missing, but is required to make the VR replication work
           if VRReady then
               UserInputService.UserCFrameChanged:Connect(OnUserCFrameChanged)
           else
               RunService.RenderStepped:Connect(function()
                   OnUserCFrameChanged(Enum.UserCFrame.Head, CFrame.new(0, 0, 0))
                   OnUserCFrameChanged(Enum.UserCFrame.LeftHand, CFrame.new(-1, -1, 0))
                   OnUserCFrameChanged(Enum.UserCFrame.RightHand, CFrame.new(1, -1, 0))
               end)
           end
           -- The rest of your script would continue here...


        --[[
         ================================================================================
         == GEMINI'S FIX: HAT & LIMB MONITOR                                           ==
         ================================================================================
         - This function checks if any of the hats used for VR limbs have disappeared or fallen.
         - If a problem is detected, it automatically resets the player to restart the VR system.
        --]]
        local function startHatMonitor()
            -- Disconnect any previous monitor to prevent duplicates
            if hatMonitorConnection then
                hatMonitorConnection:Disconnect()
                hatMonitorConnection = nil
            end
    
            -- We only need to monitor hats if RagdollEnabled is false, as that's when hats are used for limbs.
            if RagdollEnabled then
                print("CLOVR Monitor: Ragdoll mode is enabled, hat monitoring is not required.")
                return
            end
    
            local partsToMonitor = {}
            -- The virtual body and its root part are essential for distance checks
            local virtualRoot = VirtualBody and VirtualBody:FindFirstChild("HumanoidRootPart")
    
            if not virtualRoot then return end -- Cannot monitor without a reference point
    
            -- Gather all the created hat handles into one table for easy checking
            if LeftHandle then table.insert(partsToMonitor, LeftHandle) end
            if RightHandle then table.insert(partsToMonitor, RightHandle) end
            if LeftHipHandle then table.insert(partsToMonitor, LeftHipHandle) end
            if RightHipHandle then table.insert(partsToMonitor, RightHipHandle) end
            if TorsoHandle then table.insert(partsToMonitor, TorsoHandle) end
            for _, data in ipairs(HeadAccessories) do
                if data[1] then table.insert(partsToMonitor, data[1]) end
            end
    
            if #partsToMonitor == 0 then
                print("CLOVR Monitor: No hat parts were found to monitor.")
                return
            end
            
            lastHatCount = #partsToMonitor
            print("CLOVR Monitor: Actively monitoring " .. lastHatCount .. " limb pieces for glitches.")
    
            -- Connect the checker to Heartbeat, which runs every frame after physics calculations
            hatMonitorConnection = RunService.Heartbeat:Connect(function()
                if restartCooldown then return end
    
                local problemDetected = false
    
                for _, part in ipairs(partsToMonitor) do
                    -- CHECK 1: Has the part been destroyed or removed from the game?
                    if not part or not part.Parent then
                        problemDetected = true
                        print("CLOVR Monitor: A limb piece was destroyed or removed.")
                        break -- Exit the loop as soon as a problem is found
                    end
                    -- CHECK 2: Has the part fallen too far away from the character?
                    if (part.Position - virtualRoot.Position).Magnitude > 150 then
                        problemDetected = true
                        print("CLOVR Monitor: A limb piece is too far away.")
                        break
                    end
                end
    
                if problemDetected then
                    restartCooldown = true
                    hatMonitorConnection:Disconnect() -- Stop this checker to prevent it from running multiple times
    
                    print("CLOVR: A limb piece disappeared or fell. Resetting character to fix.")
                    game:GetService("StarterGui"):SetCore("SendNotification", {
                        Title = "Oxide Reanimation V3.5";
                        Duration = 8;
                        Text = "A VR component was lost. Automatically resetting character..."
                    })
    
                    _G.PDED = false -- Resetting your global flag
    
                    -- Wait a moment before resetting to ensure the notification is sent
                    task.wait(0.5) 
                    -- Reset the character. The script host should re-run this script on respawn.
                    game:GetService("Players").LocalPlayer:LoadCharacter()
                end
            end)
        end
    
        -- Start the monitoring process now that the VR setup is complete
        startHatMonitor()

    end -- End of the inner Script function
    Script() -- Execute the inner function
end

-- Run the main VR function
clovr()
